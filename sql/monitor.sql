-- 1) TABLAS
CREATE TABLE MON_BUFFER_SNAPSHOT (
  ID           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  CLIENTE      VARCHAR2(100) NOT NULL,
  TS           TIMESTAMP(3)  DEFAULT SYSTIMESTAMP NOT NULL,
  MAX_BYTES    NUMBER        NOT NULL,
  USED_BYTES   NUMBER        NOT NULL,
  CONSUMO_PCT  NUMBER        GENERATED ALWAYS AS (
                 CASE WHEN MAX_BYTES>0 THEN ROUND(100*USED_BYTES/MAX_BYTES,2) END
               ) VIRTUAL
);

CREATE TABLE MON_ALERTA (
  ID         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  DIA        DATE        DEFAULT TRUNC(SYSDATE) NOT NULL,
  HORA       VARCHAR2(8) DEFAULT TO_CHAR(SYSDATE,'HH24:MI:SS') NOT NULL,
  USUARIO    VARCHAR2(128),
  PROCESO    VARCHAR2(40),
  "SQL"      CLOB,
  CONSUMO    NUMBER,
  DETALLES   CLOB
);

-- 2) ÍNDICES
BEGIN
  EXECUTE IMMEDIATE 'CREATE INDEX IDX_SNAP_CLIENTE_TS ON MON_BUFFER_SNAPSHOT (CLIENTE, TS)';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -955 THEN RAISE; END IF; -- -955: ya existe
END;
/

-- 3) PROCEDIMIENTO: cálculo de MAX y USED del buffer cache
CREATE OR REPLACE PROCEDURE CALC_DB_BUFFER_USAGE (
  p_max_bytes  OUT NUMBER,
  p_used_bytes OUT NUMBER
) AS
  l_block_size   NUMBER;
  l_current_size NUMBER;
BEGIN
  -- Tamaño de bloque (bytes por bloque)
  SELECT TO_NUMBER(value)
  INTO   l_block_size
  FROM   v$parameter
  WHERE  name = 'db_block_size';

  -- Máximo/actual del DEFAULT buffer cache
  BEGIN
    -- Plan A: componente dinámico
    SELECT CURRENT_SIZE
    INTO   l_current_size
    FROM   v$sga_dynamic_components
    WHERE  component = 'DEFAULT buffer cache';
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      BEGIN
        -- Plan B: V$SGAINFO (columna BYTES)
        SELECT BYTES
        INTO   l_current_size
        FROM   v$sgainfo
        WHERE  name = 'Buffer Cache Size';
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          -- Plan C: db_cache_size (puede ser NULL si usa auto SGA)
          SELECT TO_NUMBER(value)
          INTO   l_current_size
          FROM   v$parameter
          WHERE  name = 'db_cache_size';

          IF l_current_size IS NULL THEN
            l_current_size := 0;
          END IF;
      END;
  END;

  -- Usado = buffers no libres * block_size
  SELECT COUNT(*) * l_block_size
  INTO   p_used_bytes
  FROM   v$bh
  WHERE  status <> 'free';

  p_max_bytes := l_current_size;
END;
/
SHOW ERRORS

-- 4) PROCEDIMIENTO PRINCIPAL: evalúa crítico y registra alertas
CREATE OR REPLACE PROCEDURE SGA_PLOTE (
  p_cliente     IN VARCHAR2,
  p_umbral_pct  IN NUMBER DEFAULT 85
) AS
  l_max   NUMBER;
  l_used  NUMBER;
  l_pct   NUMBER;
BEGIN
  CALC_DB_BUFFER_USAGE(l_max, l_used);

  INSERT INTO MON_BUFFER_SNAPSHOT (CLIENTE, MAX_BYTES, USED_BYTES)
  VALUES (p_cliente, l_max, l_used);

  l_pct := CASE WHEN l_max > 0 THEN ROUND(100*l_used/l_max,2) END;

  IF l_pct IS NOT NULL AND l_pct >= NVL(p_umbral_pct,85) THEN
    INSERT INTO MON_ALERTA (DIA, HORA, USUARIO, PROCESO, "SQL", CONSUMO, DETALLES)
    SELECT TRUNC(SYSDATE),
           TO_CHAR(SYSDATE,'HH24:MI:SS'),
           s.username,
           p.spid,
           q.sql_text,
           l_pct,
           'SID='||s.sid||' SERIAL#='||s.serial#||
           ' PROGRAM='||NVL(s.program,'-')||
           ' MODULE='||NVL(s.module,'-')||
           ' MACHINE='||NVL(s.machine,'-')
    FROM   v$session s
           JOIN v$process p ON s.paddr = p.addr
           LEFT JOIN v$sql q ON s.sql_id = q.sql_id
    WHERE  s.type   = 'USER'
    AND    s.status = 'ACTIVE';
  END IF;

  COMMIT;
END;
/
SHOW ERRORS

-- 5) WHO_IS_ACTIVE: consulta en vivo (no escribe)
CREATE OR REPLACE PROCEDURE WHO_IS_ACTIVE(p_rc OUT SYS_REFCURSOR) AS
BEGIN
  OPEN p_rc FOR
    SELECT SYSTIMESTAMP AS ts,
           s.username,
           p.spid      AS proceso,
           s.sid, s.serial#,
           s.program,
           s.sql_id,
           SUBSTR(q.sql_text,1,4000) AS sql_text
    FROM   v$session s
           JOIN v$process p ON s.paddr = p.addr
           LEFT JOIN v$sql q ON s.sql_id = q.sql_id
    WHERE  s.type = 'USER'
    AND    s.status = 'ACTIVE'
    ORDER BY s.last_call_et DESC;
END;
/
SHOW ERRORS

-- 6) PRUEBA RÁPIDA: ejecuta una corrida (ajusta cliente/umbral si quieres)
BEGIN
  SGA_PLOTE(p_cliente => 'ClienteLocal', p_umbral_pct => 85); -- umbral bajo para ver alertas
END;
/

--Prueba ejecutada en usuario local sys:
BEGIN
  SGA_PLOTE(p_cliente => 'PruebaCMD', p_umbral_pct => 1);
END;
/

-- Mostrar el último snapshot
COLUMN TS FORMAT A23
COLUMN CLIENTE FORMAT A15
SELECT TO_CHAR(ts,'YYYY-MM-DD HH24:MI:SS') AS ts,
       cliente, max_bytes, used_bytes, consumo_pct
FROM   mon_buffer_snapshot
ORDER  BY id DESC FETCH FIRST 1 ROWS ONLY;

-- Mostrar la última alerta
COLUMN DIA FORMAT A12
COLUMN HORA FORMAT A10
COLUMN USUARIO FORMAT A15
COLUMN PROCESO FORMAT A10
COLUMN CONSUMO FORMAT 9990.00
SELECT dia, hora, usuario, proceso, consumo
FROM   mon_alerta
ORDER  BY id DESC FETCH FIRST 1 ROWS ONLY;
